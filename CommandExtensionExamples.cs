/// CommandExtensionExamples.cs  ActivistInvestor / Tony T.
/// 
/// Example code for using the types in CommandExtensions.cs
/// 
/// Distributed under the terms of the MIT license.
/// 
/// Source location:
/// 
///     https://github.com/ActivistInvestor/AcMgdUtility/blob/main/CommandExtensionExamples.cs
///     

using Autodesk.AutoCAD.ApplicationServices;
using Autodesk.AutoCAD.DatabaseServices;
using Autodesk.AutoCAD.EditorInput;
using Autodesk.AutoCAD.Runtime;
using Autodesk.AutoCAD.ApplicationServices.EditorExtensions;
using Autodesk.AutoCAD.ApplicationServices.EditorInputExtensions;

namespace CommandExtensionExamples
{
   public static class CommandExtensionExamples
   {
      /// <summary>
      /// Issues the HATCHGENERATEBOUNDARY command and collects
      /// all of the objects created by it and sets them to the 
      /// pickfirst selection set. This example will collect all
      /// boundary objects generated by the command and select
      /// them.
      /// 
      /// Note that this example uses extension methods for the
      /// Editor class that are included below.
      /// </summary>

      [CommandMethod("SELECTHATCHBOUNDARY", CommandFlags.Redraw)]
      public static void MyCommand()
      {
         Document doc = Application.DocumentManager.MdiActiveDocument;
         Editor ed = doc.Editor;
         var per = ed.GetEntity<Hatch>("\nSelect Hatch: ");
         if(per.Status != PromptStatus.OK)
            return;
         ObjectId hatchId = per.ObjectId;
         var newIds = new ObjectIdCollection();
         ed.Command<Entity>(newIds, "HATCHGENERATEBOUNDARY", hatchId, "");
         if(newIds.Count > 0)
         {
            ed.SetImpliedSelection(newIds.ToArray());
         }
         else
         {
            ed.WriteMessage("\nFailed to capture hatch boundary object(s).");
         }
      }
   }

}

namespace Autodesk.AutoCAD.ApplicationServices.EditorInputExtensions
{
   using System;
   using System.Reflection;
   using System.Runtime.CompilerServices;
   using System.Runtime.InteropServices;

   public static partial class EditorInputExtensions
   {
      /// <summary>
      /// An extended overload of the Editor's GetEntity() method
      /// that uses a generic argument to constrain the selected 
      /// entity to instances of a type (and/or a derived type if 
      /// the exact argument is false), that also accepts a caller-
      /// supplied function that will be called to further validate 
      /// a successful selection.
      /// 
      /// The validate function overcomes a problem associated with
      /// repeatedly re-issing an input prompt when the method is
      /// used from a modal dialog box. Without using this method,
      /// repeated calls to GetEntity() from a modal dialog will
      /// cause the dialog to repeatedly disappear and reappear on
      /// each input prompt. This method allows validation of the
      /// selected entity from a modal dialog without causing the
      /// dialog to repeatedly show/hide. To accomplish this, the
      /// validation method can be supplied to fully-validate the
      /// user's response, and if necessary, retry input on failed
      /// validation any number of times, while the dialog remains
      /// hidden. When using a validation function, the function
      /// can display a failure message and return false, and the
      /// input prompt will be re-issued until the user cancels,
      /// or the validation function returns true. A modal dialog 
      /// will reappear after the call to this method returns.
      /// 
      /// An example that requires a user to select a closed,
      /// planar curve:
      /// 
      /// <code>
      /// 
      ///   public static ObjectId GetBoundary()
      ///   {
      ///      Document doc = Application.DocumentManager.MdiActiveDocument;
      ///      Editor ed = doc.Editor;
      ///      var rslt = ed.GetEntity<Curve>("\nSelect boundary: ", false, validate);
      ///      if(rslt.Status == PromptStatus.Ok)
      ///         return result.ObjectId;
      ///      else
      ///         return ObjectId.Null;
      ///         
      ///      // The validation method is called by GetEntity<T>,
      ///      // when an object is selected, and is passed the open
      ///      // entity. If the validation method returns false, the 
      ///      // input prompt is re-issued:
      ///      
      ///      bool validate(Curve crv, PromptEntityResult rslt, Editor ed)
      ///      {
      ///         if(!(curve.Closed && curve.IsPlanar))
      ///         {
      ///            ed.WriteMessage("\nInvalid selection," + 
      ///               " requires a closed, planar curve,");
      ///            return false;
      ///         }
      ///         return true;
      ///      }
      ///   }
      ///  
      ///       
      ///   
      /// </code>
      /// </summary>
      /// <typeparam name="T"></typeparam>
      /// <param name="editor"></param>
      /// <param name="message"></param>
      /// <param name="validate"></param>
      /// <returns></returns>

      public static PromptEntityResult GetEntity<T>(this Editor editor, string message,
         bool exact = false, Func<T, PromptEntityResult, Editor, bool> validate = null)
         where T : Entity
      {
         return GetEntity<T>(editor, new PromptEntityOptions(message), exact, validate);
      }

      public static PromptEntityResult GetEntity<T>(this Editor editor,
         PromptEntityOptions peo,
         bool exact = false,
         Func<T, PromptEntityResult, Editor, bool> validate = null) where T : Entity
      {
         if(editor == null)
            throw new ArgumentNullException(nameof(editor));
         if(peo == null)
            throw new ArgumentNullException(nameof(peo));
         if(string.IsNullOrEmpty(GetRejectMessage(peo)))
            peo.SetRejectMessage($"\nInvalid selection,  requires {typeof(T).Name},");
         peo.AddAllowedClass(typeof(T), exact && !typeof(T).IsAbstract);
         if(validate == null)
            return editor.GetEntity(peo);
         using(UserInteractionThunk.Begin())
         {
            while(true)
            {
               var result = editor.GetEntity(peo);
               if(result.Status != PromptStatus.OK)
                  return result;
               using(var tr = new OpenCloseTransaction())
               {
                  T entity = tr.GetObject(result.ObjectId, OpenMode.ForRead) as T;
                  if(validate(entity, result, editor))
                     return result;
               }
            }
         }
      }

      static FieldInfo rejectMessageField = typeof(PromptEntityOptions)
         .GetField("m_rejectMessage", BindingFlags.Instance | BindingFlags.NonPublic);

      static string GetRejectMessage(PromptEntityOptions peo)
      {
         return rejectMessageField.GetValue(peo) as string;
      }

      /// <summary>
      /// Wraps EditorUserInteraction and does nothing if
      /// there is no active modal window.
      /// </summary>

      class UserInteractionThunk : IDisposable
      {
         EditorUserInteraction wrapped;

         public UserInteractionThunk()
         {
            IntPtr hwndActive = GetActiveModalWindow();
            if(hwndActive != IntPtr.Zero)
            {
               wrapped = Start(hwndActive);
            }
         }

         public static IDisposable Begin()
         {
            return new UserInteractionThunk();
         }

         public void Dispose()
         {
            if(wrapped != null)
            {
               wrapped.Dispose();
               wrapped = null;
            }
         }

         static EditorUserInteraction Start(IntPtr hWnd)
         {
            if(ctor == null)
               throw new ArgumentNullException("EditorUserInteraction(IntPtr) constructor not found");
            return (EditorUserInteraction)ctor.Invoke(new object[] { hWnd });
         }

         static ConstructorInfo ctor =
            typeof(EditorUserInteraction).GetConstructor(typeof(IntPtr));

         const uint GW_OWNER = 4;

         [DllImport("user32.dll")]
         private static extern IntPtr GetActiveWindow();

         [DllImport("user32.dll")]
         private static extern IntPtr GetWindow(IntPtr hWnd, uint uCmd);

         [DllImport("user32.dll")]
         private static extern bool IsWindowEnabled(IntPtr hWnd);

         /// <summary>
         /// I've come across various approaches to this problem, 
         /// and none (including this one) are completely foolproof.
         /// </summary>
         /// <returns>The handle of an active modal window, or
         /// IntPtr.Zero if no active modal window is found.</returns>

         static IntPtr GetActiveModalWindow()
         {
            IntPtr hwnd = GetActiveWindow();
            if(hwnd != IntPtr.Zero && hwnd != Application.MainWindow.Handle)
            {
               IntPtr hwndOwner = GetWindow(hwnd, GW_OWNER);
               if(hwndOwner != IntPtr.Zero && !IsWindowEnabled(hwndOwner))
                  return hwnd;
            }
            return IntPtr.Zero;
         }
      }
   }

   public static partial class TypeExtensions
   {
      public static ConstructorInfo GetConstructor(this Type type, params Type[] argTypes)
      {
         return type?.GetConstructor(BindingFlags.NonPublic | BindingFlags.Public,
            null, argTypes, null);
      }
   }

}